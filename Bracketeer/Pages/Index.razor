@page "/"
@using System.Text;
@using Bracketeer.Components;

<MudGrid Class="mt-8" id="main-grid">
    <MudItem xs="12" sm="6" md="6" id="input-item">
        <MudCard Elevation="25" id="input-card" Class="rounded-lg pb-4">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h5" Align="Align.Center">Input</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent>
                    <div class="d-flex justify-center">
                        <MudTextField T="string" Label="Paste Parenthesis Experssion Here" Immediate="true" DebounceInterval="500" Variant="Variant.Outlined" @bind-Value="@InText" Lines="20" />
                    </div>
                </MudCardContent>
                <MudCardActions Class="d-flex justify-center">
                    <MudSwitch Label="Color" @bind-Checked="@DoColor" Color="Color.Success" UnCheckedColor="Color.Error" />
                <MudSwitch Label="Indent" @bind-Checked="@DoIndent" Color="Color.Success" UnCheckedColor="Color.Error" />
                </MudCardActions>
            </MudCard>
        </MudItem>
    <MudItem xs="12" sm="6" md="6" id="output-item">
            <MudCard Elevation="25" id="output-card" Class="rounded-lg pb-4">
                <MudCardHeader>
                    <CardHeaderContent>
                        <MudText Typo="Typo.h5" Align="Align.Center">Output</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
                <MudCardContent id="tree-card-content">
                       @if (DoIndent)
                        {
                            <MudTreeView Items="@TreeItems" id="out-tree" ExpandOnClick="true" Dense="true">
                                <ItemTemplate>
                                        <MudTreeViewItem @bind-Expanded="@context.IsExpanded" Items="@context.TreeItems">
                                            <Content>
                                                <MudTreeViewItemToggleButton @bind-Expanded="@context.IsExpanded" Visible="@context.HasChild" />
                                                <MudText Class=@getClass(context.Level)>@context.Text</MudText>
                                            </Content>
                                        </MudTreeViewItem>
                                    </ItemTemplate>
                            </MudTreeView>
                        }
                        else
                        {
                            <div style="width:100%">
                                @foreach(var span in spans)
                                {
                                    <ColoredText Class="@span.Item2" Text="@span.Item1" />
                                }
                                @*@OutText*@
                                </div>
@*                            <MudTextField T="string" Label="Output No Indent" Immediate="true" DebounceInterval="500" Variant="Variant.Outlined" Text="@OutText" Lines="20" />
*@                        }
                </MudCardContent>
            </MudCard>
    </MudItem>
</MudGrid>

@code{
    private string inText = "IF(({{Run Pulses Per M3 Run 1 A/F}} + {{Run Pulses Per M3 Run 2 A/F}}) > 0,1,(IF(({{Run Meter Factor Run 1 A/F}} + {{Run Meter Factor Run 2 A/F}})=0,\"\",(IF(J36=\"LITRES\",(AVERAGE({{Run Meter Factor Run 1 A/F}}:{{Run Meter Factor Run 2 A/F}})),\"\")))))";
    public string InText { get
        {
            return inText;
        }
        set
        {
            if (value != inText)
            {
                inText = value;
                OnInTextChanged();
            }
        }
    }

    public string getClass(int level)
    {
        if (doColor)
            return $"type{level + 1}";
        else
            return "";
    }

    private bool doColor = true;
    protected bool DoColor {
        get
        {
            return doColor;
        }
        set
        {
            if (value != doColor)
            {
                doColor = value;
                OnDoColorChanged();
            }
        }
    } 

    private bool doIndent = true;
    protected bool DoIndent { get
        {
            return doIndent;
        }
        set
        {
            if (doIndent != value)
            {
                doIndent = value;
                OnDoIndentChanged();
            }
        }
    }

    public string OutText { get; set; } = "";

    public List<(string, string)> spans = new List<(string, string)>();

    private HashSet<TreeItemData> TreeItems { get; set; } = new HashSet<TreeItemData>();

    public class TreeItemData
    {
        public string Text { get; set; }

        public int Level { get; set; }

        public bool IsExpanded { get; set; } = true;

        public bool HasChild => TreeItems != null && TreeItems.Count > 0;

        public HashSet<TreeItemData> TreeItems { get; set; } = new HashSet<TreeItemData>();

        public TreeItemData(string text, int level)
        {
            Level = level;
            Text = text;            
        }
    }

    private void OnDoColorChanged()
    {
       RefreshOutput();
    }

    private void OnDoIndentChanged()
    {
        RefreshOutput();
    }

    private void OnInTextChanged()
    {
        RefreshOutput();
    }

    private void RefreshOutput()
    {
        if (doIndent)
            BuildTreeItems();
        else
            BuildOutText();
    }

    public string RemoveChars(string input, params char[] chars)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < input.Length; i++)
        {
            if (!chars.Contains(input[i]))
                sb.Append(input[i]);
        }
        return sb.ToString();
    }

    private string deindent(string s)
    {
        string s2 = RemoveChars(s.Trim(), '\r', '\n', '\t');
        while (s2.Contains("  ")) s2 = s2.Replace("  ", " "); // remove double spaces
        return s2;
    }
    private void BuildOutText()
    {
        //OutText = deindent(inText);
        BuildDivItems();
    }

    private void BuildDivItems()
    {
        spans.Clear();
        //spans.Add(new ("test","type3"));
        //spans.Add(new ("test2", "type4"));

        string s = deindent(inText);
        var parent = TreeItems;
        int parenlevel = 0;
        while (s.Trim().Length > 0)
        {
            int? nextopen = s.IndexOf('(');
            if (nextopen == -1) nextopen = null;
            int? nextclose = s.IndexOf(')');
            if (nextclose == -1) nextclose = null;


            if (nextopen.HasValue && (!nextclose.HasValue || nextclose.Value > nextopen.Value))
            {
                //next bracket is open.. add node for remaining text
                spans.Add(new (s.Substring(0, nextopen.Value + 1), getClass(parenlevel)));
                parenlevel++;
                s = s.Substring(nextopen.Value + 1);
            } else
            if (nextclose.HasValue && (!nextopen.HasValue || nextopen.Value > nextclose.Value))
            {
                // next bracket is close.. add node for remaining text
                spans.Add(new(s.Substring(0, nextclose.Value+1), getClass(parenlevel)));
                s = s.Substring(nextclose.Value + 1);
                parenlevel--;
            }
        }
    }

    private void BuildTreeItems()
    {
        TreeItems.Clear();

        Stack<HashSet<TreeItemData>> parents = new Stack<HashSet<TreeItemData>>();

        string s = deindent(inText);
        var parent = TreeItems;
        int parenlevel = 0;
        while (s.Trim().Length > 0)
        {
            int? nextopen = s.IndexOf('(');
            if (nextopen == -1) nextopen = null;
            int? nextclose = s.IndexOf(')');
            if (nextclose == -1) nextclose = null;


            if (nextopen.HasValue && (!nextclose.HasValue || nextclose.Value > nextopen.Value))
            {
                //next bracket is open.. add node for remaining text
                //parent.Add(new TreeItemData(s.Substring(0, nextopen.Value)));
                //TreeItemData newchild = new TreeItemData("(");
                TreeItemData newchild = new TreeItemData(s.Substring(0, nextopen.Value + 1), parenlevel);
                TreeItemData newchild2 = new TreeItemData(")", parenlevel);
                parent.Add(newchild);
                parent.Add(newchild2);
                parents.Push(parent);
                parenlevel++;
                parent = newchild.TreeItems;
                s = s.Substring(nextopen.Value + 1);
            } else
            if (nextclose.HasValue && (!nextopen.HasValue || nextopen.Value > nextclose.Value))
            {
                // next bracket is close.. add node for remaining text
                parent.Add(new TreeItemData(s.Substring(0, nextclose.Value), parenlevel));
                s = s.Substring(nextclose.Value + 1);
                if (parents.Count == 0)
                { 
                    // mismatched paren!!
                }
                else
                    parent= parents.Pop();

                parenlevel--;
            }
        }
    }

    protected override void OnInitialized()
    {
        BuildTreeItems();
    }

}